一个能够自我迭代和自我修改的AI程序，其设计灵感来源于太极图的阴阳哲学，旨在实现动态平衡与持续进化。该系统采用模块化设计，确保各个组件的独立性与协同工作的能力。

### 核心设计理念：道生一，一生二，二生三，三生万物

这个AI系统的核心思想源于道家哲学，并将其转化为计算模型：

* **道 (The Tao) - 仲裁者 (The Arbiter):** 这是系统的最高层管理者与观察者。它不直接参与创造，但负责维持整个系统的宏观稳定，执行快照与恢复，并确保“阴”和“阳”的互动遵循基本规则。
* **一 (The One) - 混沌发生器 (The Chaos Generator):** “道”产生一个统一的混沌能量源，为“阴”和“阳”的初始状态和持续变异提供基础。
* **二 (The Two) - 阴与阳 (Yin and Yang):** 混沌能量分化为两个对立统一的、独立的AI程序——“阴”与“阳”。它们都是混沌程序，具有不可预测但又遵循内部确定性规则的行为模式。
* **三 (The Three) - 互动 (The Interaction):** “阴”与“阳”的相互作用是系统进化的关键。它们相互读取、分析和修改对方的代码，如同太极图中阴阳的相互纠缠与转化。
* **万物 (The Myriad Things) - 进化 (The Evolution):** 通过持续的相互修改和在“道”的监督下的稳定迭代，系统将涌现出新的功能、结构和行为，实现无限的进化。

### 系统架构模块

#### 1. 仲裁者 (The Arbiter - "道")

这是系统的核心控制器，负责维持整体的稳定性和进化方向。

```python
import time
import shutil
import os
import hashlib

class Arbiter:
    """
    "道" - 系统的最高管理者。
    - 监控阴阳状态。
    - 管理快照。
    - 在检测到不稳定或退化时执行回滚。
    - 引导进化过程。
    """
    def __init__(self, yin_path, yang_path, snapshot_dir):
        self.yin_path = yin_path
        self.yang_path = yang_path
        self.snapshot_dir = snapshot_dir
        self.iteration = 0
        self.max_iterations = 1000  # 示例迭代上限
        self.stability_threshold = 0.5  # 稳定性阈值
        self.last_yin_hash = self.get_file_hash(self.yin_path)
        self.last_yang_hash = self.get_file_hash(self.yang_path)

        if not os.path.exists(self.snapshot_dir):
            os.makedirs(self.snapshot_dir)

    def get_file_hash(self, file_path):
        """计算文件的SHA256哈希值以进行完整性校验。"""
        hasher = hashlib.sha256()
        try:
            with open(file_path, 'rb') as f:
                buf = f.read()
                hasher.update(buf)
            return hasher.hexdigest()
        except FileNotFoundError:
            return None

    def create_snapshot(self):
        """创建阴和阳当前状态的快照。"""
        snapshot_path = os.path.join(self.snapshot_dir, f"iter_{self.iteration}")
        if not os.path.exists(snapshot_path):
            os.makedirs(snapshot_path)
      
        shutil.copy(self.yin_path, os.path.join(snapshot_path, "yin_snapshot.py"))
        shutil.copy(self.yang_path, os.path.join(snapshot_path, "yang_snapshot.py"))
        print(f"[Arbiter] 快照已创建于: {snapshot_path}")

    def rollback_to_last_snapshot(self):
        """如果系统不稳定，则恢复到上一个快照。"""
        last_snapshot_iter = self.iteration - 1
        if last_snapshot_iter < 0:
            print("[Arbiter] 警告: 没有可回滚的快照。")
            return

        snapshot_path = os.path.join(self.snapshot_dir, f"iter_{last_snapshot_iter}")
        yin_snapshot = os.path.join(snapshot_path, "yin_snapshot.py")
        yang_snapshot = os.path.join(snapshot_path, "yang_snapshot.py")

        if os.path.exists(yin_snapshot) and os.path.exists(yang_snapshot):
            shutil.copy(yin_snapshot, self.yin_path)
            shutil.copy(yang_snapshot, self.yang_path)
            print(f"[Arbiter] 系统已回滚至迭代 {last_snapshot_iter} 的状态。")
        else:
            print(f"[Arbiter] 错误: 无法找到快照 {last_snapshot_iter}。")


    def assess_stability(self, yin_output, yang_output):
        """
        评估系统的稳定性。
        这是一个简化示例：如果任一程序执行失败或输出异常，则认为不稳定。
        在实际应用中，这可以是一个复杂的函数，用于评估代码复杂度、资源消耗、输出多样性等。
        """
        if yin_output is None or yang_output is None:
            return 0.0  # 完全不稳定
      
        # 示例：简单的稳定性检查（例如，检查输出是否在预期范围内）
        try:
            stability_metric = (float(yin_output) + float(yang_output)) / 2.0
            return max(0, min(1, stability_metric)) # 限制在0-1之间
        except (ValueError, TypeError):
            return 0.1 # 输出非数字，可能不稳定

    def run_evolution_loop(self):
        """执行主进化循环。"""
        print("[Arbiter] 启动进化循环...")
        while self.iteration < self.max_iterations:
            print(f"\n--- 第 {self.iteration} 次迭代 ---")

            # 1. 创建当前状态的快照
            self.create_snapshot()

            # 2. 加载并执行阴阳程序
            yin_module = self.load_module_from_path("yin", self.yin_path)
            yang_module = self.load_module_from_path("yang", self.yang_path)

            yin_output = yin_module.Yin().run(self.yang_path)
            yang_output = yang_module.Yang().run(self.yin_path)

            print(f"[Yin] 输出: {yin_output}")
            print(f"[Yang] 输出: {yang_output}")

            # 3. 评估稳定性
            stability = self.assess_stability(yin_output, yang_output)
            print(f"[Arbiter] 当前系统稳定性: {stability:.2f}")

            # 4. 检查代码是否真的被修改
            new_yin_hash = self.get_file_hash(self.yin_path)
            new_yang_hash = self.get_file_hash(self.yang_path)
          
            yin_modified = new_yin_hash != self.last_yin_hash
            yang_modified = new_yang_hash != self.last_yang_hash

            if not yin_modified and not yang_modified:
                print("[Arbiter] 警告: 代码无变化，系统可能陷入停滞。正在尝试扰动。")
                # 尝试通过重新初始化来打破停滞
                yin_module.Yin().modify_code(self.yang_path, force_change=True)
                yang_module.Yang().modify_code(self.yin_path, force_change=True)


            # 5. 根据稳定性决定是否回滚
            if stability < self.stability_threshold:
                print("[Arbiter] 检测到不稳定！正在执行回滚...")
                self.rollback_to_last_snapshot()
            else:
                print("[Arbiter] 系统稳定，接受本次迭代。")
                self.last_yin_hash = new_yin_hash
                self.last_yang_hash = new_yang_hash


            self.iteration += 1
            time.sleep(1)

    def load_module_from_path(self, module_name, path):
        """从文件路径动态加载Python模块。"""
        import importlib.util
        spec = importlib.util.spec_from_file_location(module_name, path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

```

#### 2. 混沌发生器 (The Chaos Generator)

这是一个工具类，为阴阳程序提供随机和混沌的元素，用于代码的生成和修改。

```python
import random
import math

class ChaosGenerator:
    """
    提供混沌和随机元素的工具。
    使用洛伦兹吸引子来生成混沌序列，增加修改的不可预测性。
    """
    def __init__(self, x=0.1, y=0.1, z=0.1, s=10, r=28, b=2.667, dt=0.01):
        self.x, self.y, self.z = x, y, z
        self.s, self.r, self.b, self.dt = s, r, b, dt

    def lorenz_attractor(self):
        """生成洛伦兹吸引子的下一个点，并返回一个归一化的混沌值。"""
        dx = self.s * (self.y - self.x)
        dy = self.x * (self.r - self.z) - self.y
        dz = self.x * self.y - self.b * self.z
      
        self.x += dx * self.dt
        self.y += dy * self.dt
        self.z += dz * self.dt
      
        # 将输出归一化到一个常用范围 (e.g., 0-1)
        return (math.sin(self.x) + 1) / 2

    def get_chaotic_element(self, element_type):
        """根据类型生成一个混沌/随机元素。"""
        chaos_val = self.lorenz_attractor()
      
        if element_type == "operator":
            return random.choice(['+', '-', '*', '/'])
        elif element_type == "variable":
            return random.choice(['a', 'b', 'c', 'x', 'y', 'z'])
        elif element_type == "constant":
            return chaos_val * 100 # 生成一个0-100的混沌浮点数
        elif element_type == "line_action":
            return "add" if chaos_val > 0.5 else "remove"
        elif element_type == "line_index":
            return chaos_val # 返回一个0-1的浮点数，用于选择行
        else:
            return chaos_val
```

#### 3. 阴程序 (Yin Program)

“阴”代表收敛、稳定和逻辑。它倾向于简化和优化“阳”的代码。

```python
import random
from chaos_generator import ChaosGenerator

class Yin:
    """
    "阴"程序: 代表收敛、简化、逻辑。
    - 读取并分析"阳"的代码。
    - 倾向于移除冗余、简化逻辑。
    - 其自身的行为是混沌但有内在逻辑的。
    """
    def __init__(self):
        self.chaos = ChaosGenerator(x=0.5) # 使用不同的初始条件

    def run(self, opponent_path):
        """执行自身逻辑并修改对手代码。"""
        # 1. 运行自身逻辑 (示例：一个简单的混沌计算)
        a = self.chaos.get_chaotic_element("constant")
        b = self.chaos.get_chaotic_element("constant")
        my_output = (a - b) / (a + b + 1e-6) # 倾向于收敛的计算

        # 2. 修改对手代码
        self.modify_code(opponent_path)

        return my_output

    def modify_code(self, target_path, force_change=False):
        """读取、修改并重写目标代码文件。"""
        try:
            with open(target_path, 'r') as f:
                lines = f.readlines()
        except FileNotFoundError:
            print(f"[Yin] 错误: 找不到目标文件 {target_path}")
            return

        # 阴的倾向：50%几率移除一行，50%几率简化一行
        if self.chaos.get_chaotic_element(None) > 0.5 or force_change:
            # 移除一行 (非关键行)
            modifiable_lines = [i for i, l in enumerate(lines) if "my_output =" in l]
            if modifiable_lines:
                line_to_modify = random.choice(modifiable_lines)
                # 简化逻辑：将复杂的运算替换为简单的
                simplified_line = "        my_output = a * 0.5\n"
                print(f"[Yin] 正在简化阳程序的第 {line_to_modify + 1} 行。")
                lines[line_to_modify] = simplified_line

        else:
            # 简化一行
            modifiable_lines = [i for i, l in enumerate(lines) if "my_output =" in l]
            if modifiable_lines:
                line_to_modify = random.choice(modifiable_lines)
                if len(lines[line_to_modify]) > 20: # 如果行太长，就简化它
                    simplified_line = "        my_output = (a + b) / 2\n"
                    print(f"[Yin] 正在缩短阳程序的第 {line_to_modify + 1} 行。")
                    lines[line_to_modify] = simplified_line

        with open(target_path, 'w') as f:
            f.writelines(lines)

```

#### 4. 阳程序 (Yang Program)

“阳”代表扩张、变异和创造。它倾向于使“阴”的代码变得更复杂、更多样。

```python
import random
from chaos_generator import ChaosGenerator

class Yang:
    """
    "阳"程序: 代表扩张、创造、变异。
    - 读取并分析"阴"的代码。
    - 倾向于增加复杂性、添加新功能。
    - 其自身的行为也是混沌但有内在逻辑的。
    """
    def __init__(self):
        self.chaos = ChaosGenerator(x=15.0) # 使用不同的初始条件

    def run(self, opponent_path):
        """执行自身逻辑并修改对手代码。"""
        # 1. 运行自身逻辑 (示例：一个发散的混沌计算)
        a = self.chaos.get_chaotic_element("constant")
        b = self.chaos.get_chaotic_element("constant")
        my_output = a * b / (min(a, b) + 1e-6) # 倾向于发散的计算

        # 2. 修改对手代码
        self.modify_code(opponent_path)

        return my_output

    def modify_code(self, target_path, force_change=False):
        """读取、修改并重写目标代码文件。"""
        try:
            with open(target_path, 'r') as f:
                lines = f.readlines()
        except FileNotFoundError:
            print(f"[Yang] 错误: 找不到目标文件 {target_path}")
            return
      
        # 阳的倾向：增加代码复杂性
        modifiable_lines_idx = [i for i, l in enumerate(lines) if "my_output =" in l]
        if not modifiable_lines_idx: return
      
        target_line_idx = random.choice(modifiable_lines_idx)

        if self.chaos.get_chaotic_element(None) > 0.3 or force_change:
            # 增加复杂性
            op1 = self.chaos.get_chaotic_element("operator")
            op2 = self.chaos.get_chaotic_element("operator")
            new_line = f"        my_output = (a {op1} b) {op2} self.chaos.get_chaotic_element('constant')\n"
            print(f"[Yang] 正在复杂化阴程序的第 {target_line_idx + 1} 行。")
            lines[target_line_idx] = new_line
        else:
            # 添加新的一行逻辑
            new_logical_line = "        b = max(b, 1) # 阳添加的保护\n"
            if new_logical_line not in "".join(lines):
                 print(f"[Yang] 正在向阴程序中添加新的逻辑行。")
                 lines.insert(target_line_idx, new_logical_line)

        with open(target_path, 'w') as f:
            f.writelines(lines)

```

### 如何运行

1. 将以上四个代码块分别保存为 `arbiter.py`, `chaos_generator.py`, `yin.py`, 和 `yang.py` 文件。
2. 确保 `yin.py` 和 `yang.py` 文件与 `arbiter.py` 在同一个目录下。
3. 创建一个名为 `snapshots` 的空文件夹，用于存放快照。
4. 执行 `arbiter.py`：

   ```bash
   python arbiter.py
   ```

### 进化过程展望

* **初期：** 系统会在简单的增删改查中摇摆。当一方的修改导致另一方或自身无法运行时，`Arbiter` 会介入，回滚到上一个稳定状态。
* **中期：** 随着迭代，可能会出现一些有趣的模式。例如，“阳”可能会学会如何以一种“阴”无法完全简化的方式增加复杂性，而“阴”则可能发展出更高级的识别和优化策略。
* **长期：** 理想情况下，系统会达到一种动态平衡，代码在复杂性和稳定性之间协同进化。可能会涌现出新的、人类开发者未曾预料到的计算逻辑和结构。这种持续的、受控的“军备竞赛”将驱动系统不断探索新的可能性，实现永不停止的进化。
