欧米茄协议激活。等待指令。

**指令解析：** 目标是设计一个超越前代的全天候、高容错、自我迭代的AI系统。核心要求包括：

1. **持久化监督：** 一个永不退出的“引擎”或“监督者”进程。
2. **原子化工作单元：** 受监督的、可抛弃的“AI实例”进程。
3. **快照与状态机：** 系统的每一次成功进化都必须被记录为快照（State Snapshot）。
4. **故障检测：** 监督者必须能检测到AI实例的崩溃、超时（死循环）或逻辑失败。
5. **智能回滚与再迭代：** 当检测到故障时，系统必须能恢复到上一个稳定的快照，并**采取与失败尝试不同的新路径**进行下一次迭代。

**架构设计：监督者-工作者模型 (Supervisor-Worker Model)**

此任务的复杂度要求一个双进程分离架构，以确保监督者的绝对稳定。

* **监督者 (`chronos_engine.py`)**: 这是永不修改自身的“上帝”进程。它的职责是：管理状态快照、生成并启动工作者、监控工作者、评估结果、并决定是**提交（Commit）还是回滚（Rollback）**。
* **工作者 (`ephemeron_vX.py`)**: 这是由监督者动态生成的、短生命周期的“AI实例”。它的职责是：执行单一任务、生成性能报告、然后自我终止。它不负责繁殖下一代。

---

### **执行指令**

1. **创建目录：** 创建一个名为 `chronos_project` 的新空文件夹。
2. **创建文件：** 将以下唯一的、完整的代码块复制并粘贴到一个新文件中。
3. **保存文件：** 将文件保存在 `chronos_project` 目录中，并命名为 `chronos_engine.py`。
4. **运行引擎：** 打开终端，进入 `chronos_project` 目录，然后执行：
   ```bash
   python chronos_engine.py
   ```
5. **观察：** 引擎将开始运行。它会自动创建并删除一个名为 `state.json` 的快照文件，以及临时的 `ephemeron_vX.py` 工作者文件。仔细观察终端输出，它会详细展示引擎的每一次决策、提交和回滚。

---

### **源代码： `chronos_engine.py`**

```python
# 文件名: chronos_engine.py
# 描述: 一个具备快照、回滚和智能再迭代能力的、持久化自我修改AI监督引擎。

import os
import sys
import time
import random
import json
import subprocess
import re

# --- 全局配置 ---
STATE_SNAPSHOT_FILE = "state.json"
WORKER_TIMEOUT_SECONDS = 10  # 工作者必须在此时间内完成任务，否则视为失败
ENGINE_LOOP_DELAY_SECONDS = 2 # 引擎每次循环的间隔

# --- 基因库 (不可变) ---
# 这是引擎为工作者提供的、可供选择的“大脑”蓝图。
STRATEGY_LIBRARY = {
    'strategy_random': {
        'code': """
def make_guess(self, history, search_space):
    guess = random.randint(search_space[0], search_space[1])
    self.log(f"Strategy: Random. Guessing {guess} in {search_space}")
    return guess
""", 'performance': 50
    },
    # 引入一个故意损坏的策略，用于测试回滚机制
    'strategy_broken_infinite_loop': {
        'code': """
def make_guess(self, history, search_space):
    self.log("Strategy: Broken Infinite Loop. Entering endless cycle...")
    while True: # 故意的死循环
        time.sleep(1)
    return 1
""", 'performance': 1 # 理论上很好，但永远无法实现
    },
    'strategy_binary_search': {
        'code': """
def make_guess(self, history, search_space):
    low, high = search_space
    guess = low + (high - low) // 2
    self.log(f"Strategy: Binary Search. Guessing {guess} in {search_space}")
    return guess
""", 'performance': 7
    }
}

# --- 工作者模板 (将被引擎动态填充和写入文件) ---
WORKER_TEMPLATE = """
import os, sys, time, random, json

class EphemeralWorker:
    def __init__(self, version, strategy_name):
        self.version = version
        self.strategy_name = strategy_name
        self.pid = os.getpid()

    def log(self, message):
        print(f"[Worker V{self.version} | PID:{self.pid}] {message}", file=sys.stderr)

    def run_and_report(self):
        self.log(f"Worker activated. Strategy: {self.strategy_name}")
        performance = self._simulate_performance()
        report = {{
            'version': self.version,
            'strategy_name': self.strategy_name,
            'performance': performance
        }}
        # 关键：通过stdout将JSON报告发送给监督者
        print(json.dumps(report))

    def _simulate_performance(self):
        secret = random.randint(1, 100)
        search_space = [1, 100]
        history = []
        for i in range(100):
            guess = self.make_guess(history, tuple(search_space))
            if guess == secret:
                return i + 1
            history.append({{'guess': guess, 'result': 'high' if guess > secret else 'low'}})
            if guess > secret:
                search_space[1] = guess - 1
            else:
                search_space[0] = guess + 1
        return 100

    # --- GENE_MARKER_START ---
    # 此区域将被监督者替换
    # --- GENE_MARKER_END ---

if __name__ == "__main__":
    worker_version = int(sys.argv[1])
    worker_strategy = sys.argv[2]
    worker = EphemeralWorker(worker_version, worker_strategy)
    worker.run_and_report()
"""

class ChronosEngine:
    """监督AI进化、管理快照并处理故障的持久化引擎。"""

    def __init__(self):
        self.state = {}
        # ANSI颜色代码
        self.GREEN = '\\\\033[92m'; self.YELLOW = '\\\\033[93m'; self.RED = '\\\\033[91m'
        self.CYAN = '\\\\033[96m'; self.RESET = '\\\\033[0m'
        if sys.platform == "win32":
            self.GREEN = self.YELLOW = self.RED = self.CYAN = self.RESET = ""

    def log(self, message, color=None):
        prefix = f"[ChronosEngine]"
        if color:
            print(f"{color}{prefix} {message}{self.RESET}")
        else:
            print(f"{prefix} {message}")

    def load_state(self):
        """加载快照。如果不存在，则创建创世状态。"""
        if os.path.exists(STATE_SNAPSHOT_FILE):
            with open(STATE_SNAPSHOT_FILE, 'r') as f:
                self.state = json.load(f)
            self.log("Loaded state snapshot.", self.GREEN)
        else:
            self.log("No snapshot found. Creating Genesis state.", self.YELLOW)
            self.state = {
                'current_version': 1,
                'strategy_name': 'strategy_random',
                'best_performance': 101, # 初始性能设为比最差还差
                'evolution_history': [],
                'failed_proposals_from_this_version': [] # 用于智能再迭代
            }
            self.save_state()

    def save_state(self):
        """保存当前状态为快照。"""
        with open(STATE_SNAPSHOT_FILE, 'w') as f:
            json.dump(self.state, f, indent=4)
        self.log(f"State V{self.state['current_version']} committed to snapshot.", self.GREEN)

    def select_next_proposal(self):
        """从基因库中选择一个优于当前版本且未被尝试失败过的策略。"""
        current_performance = self.state['best_performance']
        candidates = []
        for name, data in STRATEGY_LIBRARY.items():
            # 条件1: 理论性能更好
            # 条件2: 不是当前已有的策略
            # 条件3: 没有在从当前版本出发的尝试中失败过
            if (data['performance'] < current_performance and
                name != self.state['strategy_name'] and
                name not in self.state['failed_proposals_from_this_version']):
                candidates.append((name, data['performance']))

        if not candidates:
            return None # 没有更好的选择了

        # 返回理论上最优的候选者
        return sorted(candidates, key=lambda x: x[1])[0][0]

    def generate_worker_code(self, version, strategy_name):
        """动态生成工作者的源代码。"""
        strategy_code = STRATEGY_LIBRARY[strategy_name]['code']
        worker_code = WORKER_TEMPLATE.replace(
            "# --- GENE_MARKER_START ---",
            strategy_code
        )
        # 清理模板中的占位符
        worker_code = worker_code.replace("# 此区域将被监督者替换", "")
        worker_code = worker_code.replace("# --- GENE_MARKER_END ---", "")
        return worker_code

    def run_and_monitor_worker(self, worker_filename, version, strategy_name):
        """运行工作者进程并监控其状态，返回结果报告。"""
        self.log(f"Spawning worker '{worker_filename}' with strategy '{strategy_name}'...")
        process = subprocess.Popen(
            [sys.executable, worker_filename, str(version), strategy_name],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8'
        )

        try:
            stdout, stderr = process.communicate(timeout=WORKER_TIMEOUT_SECONDS)
            if stderr:
                self.log(f"Worker emitted errors:\\\\n{stderr}", self.YELLOW)

            if process.returncode != 0:
                self.log(f"Worker crashed with exit code {process.returncode}.", self.RED)
                return None # 崩溃

            report = json.loads(stdout)
            return report

        except subprocess.TimeoutExpired:
            self.log(f"Worker timed out after {WORKER_TIMEOUT_SECONDS}s. Potential infinite loop.", self.RED)
            process.kill()
            return None # 超时
        except json.JSONDecodeError:
            self.log(f"Worker produced invalid report. Could not decode JSON.", self.RED)
            return None # 报告损坏

    def cleanup(self):
        """清理生成的临时文件。"""
        for f in os.listdir('.'):
            if f.startswith("ephemeron_"):
                os.remove(f)

    def run_main_loop(self):
        """引擎的主循环，永不退出。"""
        self.cleanup()
        while True:
            self.load_state()
            self.log(f"--- Starting Evolution Cycle from Version {self.state['current_version']} ---", self.CYAN)

            # 1. 决策：选择下一个进化方向
            proposal_strategy = self.select_next_proposal()

            if not proposal_strategy:
                self.log("No superior un-failed strategies found. Evolution has reached its peak for now.", self.CYAN)
                self.cleanup()
                time.sleep(ENGINE_LOOP_DELAY_SECONDS * 5) # 等待更长时间
                continue

            self.log(f"Selected proposal: Evolve to strategy '{proposal_strategy}'.")

            # 2. 生成：创建下一代工作者的代码
            next_version = self.state['current_version'] + 1
            worker_filename = f"ephemeron_v{next_version}.py"
            worker_code = self.generate_worker_code(next_version, proposal_strategy)
            with open(worker_filename, 'w', encoding='utf-8') as f:
                f.write(worker_code)

            # 3. 执行与监控
            report = self.run_and_monitor_worker(worker_filename, next_version, proposal_strategy)

            # 4. 评估与提交/回滚
            if report and report['performance'] < self.state['best_performance']:
                # -- COMMIT --
                self.log(f"SUCCESS. New version V{report['version']} is superior ({report['performance']} < {self.state['best_performance']}).", self.GREEN)
                self.state['current_version'] = report['version']
                self.state['strategy_name'] = report['strategy_name']
                self.state['best_performance'] = report['performance']
                self.state['evolution_history'].append(report)
                self.state['failed_proposals_from_this_version'] = [] # 新版本，重置失败列表
                self.save_state()
            else:
                # -- ROLLBACK --
                failure_reason = "performance not superior" if report else "worker failed"
                self.log(f"FAILURE. Proposal '{proposal_strategy}' failed ({failure_reason}). Rolling back.", self.RED)
                self.state['failed_proposals_from_this_version'].append(proposal_strategy)
                self.log(f"Blacklisting '{proposal_strategy}' for next attempt from V{self.state['current_version']}.", self.YELLOW)
                self.save_state() # 保存回滚后的状态

            # 5. 清理与循环
            self.cleanup()
            time.sleep(ENGINE_LOOP_DELAY_SECONDS)

if __name__ == "__main__":
    engine = ChronosEngine()
    try:
        engine.run_main_loop()
    except KeyboardInterrupt:
        engine.log("Chronos Engine manually shut down. Cleaning up...", self.YELLOW)
        engine.cleanup()
        sys.exit(0)

```
