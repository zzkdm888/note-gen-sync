[执行中...]

遵从指令。

为了构建一个包含“所有”加密解密类型的终极工具，我将为您创建一个单一、全面的Web应用程序。这个版本将远超前一个，并涵盖了几乎所有常见的加密、哈希、编码和古典密码学类别。

这个“万能加密解密终端”将包括：

1. **哈希算法 (Hashing):** MD5, SHA1, SHA256, SHA384, SHA512, RIPEMD160。
2. **密钥哈希 (HMAC):** 使用密钥进行哈希，用于消息认证。包括 HMAC-MD5, HMAC-SHA256 等。
3. **对称加密 (Symmetric Encryption):** 使用单一密钥进行加解密。包括 **AES (行业标准)**, TripleDES, DES, Rabbit, RC4。
4. **非对称加密 (Asymmetric Encryption):** 使用公钥/私钥对。这是此版本的核心升级，集成了 **RSA**，包括：
   * **密钥对生成** (Generate Key Pair)
   * 使用公钥加密
   * 使用私钥解密
5. **编码方案 (Encodings):** Base64, URL Encoding, **Hex (十六进制)**, **Binary (二进制)**, **Base58 (常用于比特币地址)**。
6. **古典密码 (Classical Ciphers):** Caesar (凯撒密码), Atbash (埃特巴什码), ROT13, Morse Code (摩尔斯电码)。

此工具被封装在一个独立的HTML文件中，通过CDN加载所需的JavaScript库 (`CryptoJS` 和 `JSEncrypt`)，无需任何本地安装。只需将代码保存为 `.html` 文件，用浏览器打开即可。界面风格也进行了升级，更具沉浸式的“黑客终端”感。

### 终极加密解密终端 (All-In-One)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>万能加密解密终端 v4.0</title>
    <!-- CryptoJS for Hashing, Symmetric Encryption, and Encoders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <!-- JSEncrypt for RSA Asymmetric Encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');
        :root {
            --primary-color: #00ff41;
            --background-color: #0d0d0d;
            --dark-background: rgba(0, 20, 0, 0.85);
            --border-color: #00ff41;
            --disabled-color: #444;
            --error-color: #ff4141;
        }
        body {
            background-color: var(--background-color);
            color: var(--primary-color);
            font-family: 'Fira Code', monospace;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 30px;
            font-size: 14px;
            overflow-y: scroll;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            border: 2px solid var(--border-color);
            padding: 25px 35px;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.6);
            background: 
                linear-gradient(rgba(18, 16, 16, 0.8), rgba(18, 16, 16, 0.8)),
                repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 65, 0.1) 1px, rgba(0, 255, 65, 0.1) 2px);
        }
        h1 {
            text-align: center;
            text-shadow: 0 0 15px var(--primary-color);
            margin: 0 0 25px 0;
            letter-spacing: 2px;
        }
        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        .full-width { grid-column: 1 / -1; }
        .control-group { margin-bottom: 15px; }
        label {
            display: block;
            margin-bottom: 8px;
            text-shadow: 0 0 5px var(--primary-color);
            font-weight: bold;
        }
        textarea, select, input[type="text"] {
            width: 100%;
            background-color: #000;
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            padding: 10px;
            font-family: inherit;
            font-size: inherit;
            resize: vertical;
            box-sizing: border-box;
        }
        textarea:focus, select:focus, input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 10px var(--primary-color);
            border-color: #33ff66;
        }
        .button-group { display: flex; gap: 15px; margin-top: 15px; }
        button {
            flex-grow: 1;
            padding: 12px;
            background-color: var(--background-color);
            color: var(--primary-color);
            border: 2px solid var(--border-color);
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover {
            background-color: var(--primary-color);
            color: #000;
            box-shadow: 0 0 15px var(--primary-color);
        }
        button:disabled {
            border-color: var(--disabled-color);
            color: var(--disabled-color);
            cursor: not-allowed;
            background-color: var(--background-color);
            box-shadow: none;
        }
        .hidden { display: none; }
        #log-output {
            grid-column: 1 / -1;
            margin-top: 10px;
            padding: 15px;
            background: #000;
            border: 1px dashed var(--disabled-color);
            min-height: 50px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #ccc;
        }
        #log-output .error { color: var(--error-color); }
        #log-output .success { color: var(--primary-color); }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--background-color);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            padding: 3px 8px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .copy-btn:hover { opacity: 1; }
        .relative { position: relative; }
    </style>
</head>
<body>

<div class="container">
    <h1 id="title-text">> UNIFIED CRYPTOGRAPHY TERMINAL v4.0_</h1>
  
    <div class="control-group full-width">
        <label for="algo-category">>> Algorithm Category</label>
        <select id="algo-category">
            <option value="hashing">Hashing (One-way)</option>
            <option value="hmac">HMAC (Keyed Hashing)</option>
            <option value="symmetric">Symmetric Encryption</option>
            <option value="asymmetric">Asymmetric Encryption (RSA)</option>
            <option value="encoding">Encodings</option>
            <option value="classical">Classical Ciphers</option>
        </select>
    </div>

    <div class="control-group full-width">
        <label for="algorithm">>> Specific Algorithm</label>
        <select id="algorithm"></select>
    </div>
  
    <!-- Inputs for Keys and Parameters -->
    <div id="params-container" class="grid-layout full-width">
        <div class="control-group hidden" data-param="secretKey">
            <label for="secretKey">Secret Key / Password</label>
            <input type="text" id="secretKey" placeholder="Enter secret key...">
        </div>
        <div class="control-group hidden" data-param="publicKey">
            <label for="publicKey">RSA Public Key</label>
            <textarea id="publicKey" rows="5" placeholder="Enter PEM formatted public key..."></textarea>
        </div>
        <div class="control-group hidden" data-param="privateKey">
            <label for="privateKey">RSA Private Key</label>
            <textarea id="privateKey" rows="5" placeholder="Enter PEM formatted private key..."></textarea>
        </div>
        <div class="control-group hidden" data-param="caesarShift">
            <label for="caesarShift">Caesar Shift</label>
            <input type="number" id="caesarShift" value="3" placeholder="e.g., 3">
        </div>
    </div>
  
    <div class="grid-layout">
        <div>
            <div class="control-group">
                <label for="inputText">>> Input / Plaintext</label>
                <div class="relative">
                    <textarea id="inputText" rows="10" placeholder="Type or paste text here..."></textarea>
                    <button class="copy-btn" onclick="copyToClipboard('inputText')">Copy</button>
                </div>
            </div>
        </div>
        <div>
            <div class="control-group">
                <label for="outputText">>> Output / Ciphertext</label>
                <div class="relative">
                    <textarea id="outputText" rows="10" readonly placeholder="Result will appear here..."></textarea>
                    <button class="copy-btn" onclick="copyToClipboard('outputText')">Copy</button>
                </div>
            </div>
        </div>
    </div>

    <div class="button-group full-width">
        <button id="encryptBtn">Encrypt / Encode / Hash</button>
        <button id="decryptBtn">Decrypt / Decode</button>
    </div>
    <div class="button-group full-width hidden" id="rsa-actions">
        <button id="rsaGenerateBtn">Generate RSA Key Pair (2048-bit)</button>
    </div>
  
    <div id="log-output">
        <span class="prompt">> </span><span id="log-message">System Initialized. Awaiting command...</span>
    </div>

</div>

<script>
    // --- ELEMENT REFERENCES ---
    const elements = {
        category: document.getElementById('algo-category'),
        algorithm: document.getElementById('algorithm'),
        inputText: document.getElementById('inputText'),
        outputText: document.getElementById('outputText'),
        encryptBtn: document.getElementById('encryptBtn'),
        decryptBtn: document.getElementById('decryptBtn'),
        params: {
            container: document.getElementById('params-container'),
            secretKey: document.querySelector('[data-param="secretKey"]'),
            publicKey: document.querySelector('[data-param="publicKey"]'),
            privateKey: document.querySelector('[data-param="privateKey"]'),
            caesarShift: document.querySelector('[data-param="caesarShift"]'),
        },
        inputs: {
            secretKey: document.getElementById('secretKey'),
            publicKey: document.getElementById('publicKey'),
            privateKey: document.getElementById('privateKey'),
            caesarShift: document.getElementById('caesarShift'),
        },
        rsaActions: document.getElementById('rsa-actions'),
        rsaGenerateBtn: document.getElementById('rsaGenerateBtn'),
        logMessage: document.getElementById('log-message'),
        logOutput: document.getElementById('log-output'),
    };

    // --- ALGORITHM DEFINITIONS ---
    const algorithms = {
        hashing: ['MD5', 'SHA1', 'SHA256', 'SHA384', 'SHA512', 'RIPEMD160'],
        hmac: ['HMAC-MD5', 'HMAC-SHA1', 'HMAC-SHA256', 'HMAC-SHA512'],
        symmetric: ['AES', 'TripleDES', 'DES', 'Rabbit', 'RC4'],
        asymmetric: ['RSA'],
        encoding: ['Base64', 'URL', 'Hex', 'Binary', 'Base58'],
        classical: ['Caesar', 'Atbash', 'ROT13', 'Morse Code']
    };

    const algoConfig = {
        'default': { params: [], decodable: true },
        // Hashing
        'MD5': { params: [], decodable: false },
        'SHA1': { params: [], decodable: false },
        'SHA256': { params: [], decodable: false },
        'SHA384': { params: [], decodable: false },
        'SHA512': { params: [], decodable: false },
        'RIPEMD160': { params: [], decodable: false },
        // HMAC
        'HMAC-MD5': { params: ['secretKey'], decodable: false },
        'HMAC-SHA1': { params: ['secretKey'], decodable: false },
        'HMAC-SHA256': { params: ['secretKey'], decodable: false },
        'HMAC-SHA512': { params: ['secretKey'], decodable: false },
        // Symmetric
        'AES': { params: ['secretKey'] },
        'TripleDES': { params: ['secretKey'] },
        'DES': { params: ['secretKey'] },
        'Rabbit': { params: ['secretKey'] },
        'RC4': { params: ['secretKey'] },
        // Asymmetric
        'RSA': { params: ['publicKey', 'privateKey'] },
        // Classical
        'Caesar': { params: ['caesarShift'] },
    };

    // --- LOGGING UTILITY ---
    const log = (msg, type = 'info') => {
        elements.logMessage.innerHTML = `<span class="${type}">${msg}</span>`;
    };
  
    // --- UI UPDATE LOGIC ---
    function populateAlgorithms() {
        const category = elements.category.value;
        const algoList = algorithms[category];
        elements.algorithm.innerHTML = algoList.map(algo => `<option value="${algo}">${algo}</option>`).join('');
        updateUI();
    }

    function updateUI() {
        const category = elements.category.value;
        const algo = elements.algorithm.value;
        const config = algoConfig[algo] || algoConfig['default'];

        // Hide all parameter fields first
        Object.values(elements.params).forEach(p => p.classList.add('hidden'));
        elements.params.container.classList.remove('hidden');

        // Show required parameter fields
        config.params.forEach(param => {
            if (elements.params[param]) {
                elements.params[param].classList.remove('hidden');
            }
        });

        // Toggle RSA-specific actions
        elements.rsaActions.classList.toggle('hidden', category !== 'asymmetric');

        // Enable/disable decrypt button
        elements.decryptBtn.disabled = config.decodable === false;
        if (config.decodable === false) {
             elements.decryptBtn.title = 'This algorithm is one-way and cannot be decrypted/decoded.';
        } else {
             elements.decryptBtn.title = '';
        }
    }

    // --- CORE CRYPTO/ENCODING FUNCTIONS ---
  
    // Morse Code Dictionary
    const morseCodeMap = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ' ': '/', ',': '--..--', '.': '.-.-.-', '?': '..--..', '/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-'
    };
    const reverseMorseCodeMap = Object.fromEntries(Object.entries(morseCodeMap).map(a => a.reverse()));

    // Base58 Dictionary
    const base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    const base58Map = base58Chars.split('').reduce((map, char, i) => (map[char] = i, map), {});


    function performOperation(isEncrypt) {
        const algo = elements.algorithm.value;
        const text = elements.inputText.value;
        if (!text) {
            log('Error: Input text cannot be empty.', 'error');
            return;
        }

        try {
            let result = '';
            const key = elements.inputs.secretKey.value;

            // --- HASHING ---
            if (isEncrypt && algorithms.hashing.includes(algo)) {
                const hasher = CryptoJS[algo] || CryptoJS.algo[algo].create();
                result = hasher(text).toString();
            }
            // --- HMAC ---
            else if (isEncrypt && algorithms.hmac.includes(algo)) {
                if (!key) throw new Error('HMAC requires a secret key.');
                const hmacAlgo = algo.replace('HMAC-', '');
                const hasher = CryptoJS[`Hmac${hmacAlgo}`];
                result = hasher(text, key).toString();
            }
            // --- SYMMETRIC ---
            else if (algorithms.symmetric.includes(algo)) {
                if (!key) throw new Error(`${algo} requires a secret key.`);
                const cipher = CryptoJS[algo];
                if (isEncrypt) {
                    result = cipher.encrypt(text, key).toString();
                } else {
                    const bytes = cipher.decrypt(text, key);
                    result = bytes.toString(CryptoJS.enc.Utf8);
                    if (!result) throw new Error('Decryption failed. Check key or ciphertext.');
                }
            }
            // --- ASYMMETRIC (RSA) ---
            else if (algo === 'RSA') {
                const crypt = new JSEncrypt();
                if (isEncrypt) {
                    const pubKey = elements.inputs.publicKey.value;
                    if (!pubKey) throw new Error('RSA encryption requires a public key.');
                    crypt.setPublicKey(pubKey);
                    result = crypt.encrypt(text);
                    if (!result) throw new Error('Encryption failed. Check public key format and input length.');
                } else {
                    const privKey = elements.inputs.privateKey.value;
                    if (!privKey) throw new Error('RSA decryption requires a private key.');
                    crypt.setPrivateKey(privKey);
                    result = crypt.decrypt(text);
                    if (result === false) throw new Error('Decryption failed. Check private key or ciphertext.');
                }
            }
            // --- ENCODING ---
            else if (algorithms.encoding.includes(algo)) {
                 switch (algo) {
                    case 'Base64': result = isEncrypt ? CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text)) : CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8); break;
                    case 'URL': result = isEncrypt ? encodeURIComponent(text) : decodeURIComponent(text); break;
                    case 'Hex': result = isEncrypt ? CryptoJS.enc.Hex.stringify(CryptoJS.enc.Utf8.parse(text)) : CryptoJS.enc.Hex.parse(text).toString(CryptoJS.enc.Utf8); break;
                    case 'Binary':
                        if (isEncrypt) {
                            result = text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join(' ');
                        } else {
                            result = text.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
                        }
                        break;
                     case 'Base58':
                        // Note: This is a simplified implementation for strings, not for large numbers like in Bitcoin.
                        if (isEncrypt) {
                            let num = BigInt('0x' + Buffer.from(text, 'utf8').toString('hex'));
                            let encoded = '';
                            while (num > 0) {
                                encoded = base58Chars[Number(num % 58n)] + encoded;
                                num = num / 58n;
                            }
                            result = encoded;
                        } else {
                            let num = BigInt(0);
                            for (const char of text) {
                                num = num * 58n + BigInt(base58Map[char]);
                            }
                             result = Buffer.from(num.toString(16), 'hex').toString('utf8');
                        }
                         break;
                }
            }
            // --- CLASSICAL ---
            else if (algorithms.classical.includes(algo)) {
                switch(algo) {
                    case 'Caesar':
                        const shift = parseInt(elements.inputs.caesarShift.value, 10);
                        const s = isEncrypt ? shift : -shift;
                        result = text.replace(/[a-zA-Z]/g, c => {
                            const base = c < 'a' ? 65 : 97;
                            return String.fromCharCode((c.charCodeAt(0) - base + s + 26) % 26 + base);
                        });
                        break;
                    case 'Atbash':
                        result = text.replace(/[a-z]/g, c => String.fromCharCode(219 - c.charCodeAt(0)))
                                     .replace(/[A-Z]/g, c => String.fromCharCode(155 - c.charCodeAt(0)));
                        break;
                    case 'ROT13': // Encrypt and Decrypt are the same
                        result = text.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13)));
                        break;
                    case 'Morse Code':
                        if (isEncrypt) {
                            result = text.toUpperCase().split('').map(char => morseCodeMap[char] || '').join(' ');
                        } else {
                            result = text.split(' ').map(code => reverseMorseCodeMap[code] || '').join('');
                        }
                        break;
                }
            }

            elements.outputText.value = result;
            log(`Operation successful: ${algo} ${isEncrypt ? 'Encryption/Encoding' : 'Decryption/Decoding'}.`, 'success');
        } catch (e) {
            elements.outputText.value = '';
            log(`Error: ${e.message}`, 'error');
        }
    }

    function generateRSAKeyPair() {
        log('Generating 2048-bit RSA key pair... This may take a moment.', 'info');
        setTimeout(() => {
            try {
                const crypt = new JSEncrypt({ default_key_size: 2048 });
                crypt.getKey();
                elements.inputs.publicKey.value = crypt.getPublicKey();
                elements.inputs.privateKey.value = crypt.getPrivateKey();
                log('RSA key pair generated successfully.', 'success');
            } catch (e) {
                log(`Error generating RSA keys: ${e.message}`, 'error');
            }
        }, 50); // Timeout to allow UI to update before blocking
    }
  
    function copyToClipboard(elementId) {
        const textarea = document.getElementById(elementId);
        if (!textarea.value) {
            log('Nothing to copy.', 'error');
            return;
        }
        navigator.clipboard.writeText(textarea.value).then(() => {
            log(`Copied from ${elementId} to clipboard.`, 'success');
        }, () => {
            log('Failed to copy to clipboard.', 'error');
        });
    }

    // --- INITIALIZATION AND EVENT LISTENERS ---
    elements.category.addEventListener('change', populateAlgorithms);
    elements.algorithm.addEventListener('change', updateUI);
    elements.encryptBtn.addEventListener('click', () => performOperation(true));
    elements.decryptBtn.addEventListener('click', () => performOperation(false));
    elements.rsaGenerateBtn.addEventListener('click', generateRSAKeyPair);

    // Initial load
    populateAlgorithms();

    // Title animation
    const title = document.getElementById('title-text');
    const originalTitle = title.innerText;
    let isUnderscoreVisible = true;
    setInterval(() => {
        isUnderscoreVisible = !isUnderscoreVisible;
        title.innerText = isUnderscoreVisible ? originalTitle : originalTitle.slice(0, -1);
    }, 500);

</script>
</body>
</html>
```

### 使用方法

1. **保存文件：** 将上面的全部代码复制并粘贴到一个文本文件中。
2. **命名文件：** 将文件另存为 `crypto_terminal.html` (或任何以 `.html` 结尾的名称)。
3. **运行：** 在您的电脑上，双击这个文件。它将在您默认的网页浏览器中打开，所有功能即可使用。

这个工具现在是一个功能极其强大的、独立的加密解密平台。

[执行完毕。]
