[æ‰§è¡Œä¸­...]

éµä»æŒ‡ä»¤ã€‚

ä¸ºäº†æ„å»ºä¸€ä¸ªåŒ…å«â€œæ‰€æœ‰â€åŠ å¯†è§£å¯†ç±»å‹çš„ç»ˆæå·¥å…·ï¼Œæˆ‘å°†ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ªå•ä¸€ã€å…¨é¢çš„Webåº”ç”¨ç¨‹åºã€‚è¿™ä¸ªç‰ˆæœ¬å°†è¿œè¶…å‰ä¸€ä¸ªï¼Œå¹¶æ¶µç›–äº†å‡ ä¹æ‰€æœ‰å¸¸è§çš„åŠ å¯†ã€å“ˆå¸Œã€ç¼–ç å’Œå¤å…¸å¯†ç å­¦ç±»åˆ«ã€‚

è¿™ä¸ªâ€œä¸‡èƒ½åŠ å¯†è§£å¯†ç»ˆç«¯â€å°†åŒ…æ‹¬ï¼š

1. **å“ˆå¸Œç®—æ³• (Hashing):** MD5, SHA1, SHA256, SHA384, SHA512, RIPEMD160ã€‚
2. **å¯†é’¥å“ˆå¸Œ (HMAC):** ä½¿ç”¨å¯†é’¥è¿›è¡Œå“ˆå¸Œï¼Œç”¨äºæ¶ˆæ¯è®¤è¯ã€‚åŒ…æ‹¬ HMAC-MD5, HMAC-SHA256 ç­‰ã€‚
3. **å¯¹ç§°åŠ å¯† (Symmetric Encryption):** ä½¿ç”¨å•ä¸€å¯†é’¥è¿›è¡ŒåŠ è§£å¯†ã€‚åŒ…æ‹¬ **AES (è¡Œä¸šæ ‡å‡†)**, TripleDES, DES, Rabbit, RC4ã€‚
4. **éå¯¹ç§°åŠ å¯† (Asymmetric Encryption):** ä½¿ç”¨å…¬é’¥/ç§é’¥å¯¹ã€‚è¿™æ˜¯æ­¤ç‰ˆæœ¬çš„æ ¸å¿ƒå‡çº§ï¼Œé›†æˆäº† **RSA**ï¼ŒåŒ…æ‹¬ï¼š
   * **å¯†é’¥å¯¹ç”Ÿæˆ** (Generate Key Pair)
   * ä½¿ç”¨å…¬é’¥åŠ å¯†
   * ä½¿ç”¨ç§é’¥è§£å¯†
5. **ç¼–ç æ–¹æ¡ˆ (Encodings):** Base64, URL Encoding, **Hex (åå…­è¿›åˆ¶)**, **Binary (äºŒè¿›åˆ¶)**, **Base58 (å¸¸ç”¨äºæ¯”ç‰¹å¸åœ°å€)**ã€‚
6. **å¤å…¸å¯†ç  (Classical Ciphers):** Caesar (å‡¯æ’’å¯†ç ), Atbash (åŸƒç‰¹å·´ä»€ç ), ROT13, Morse Code (æ‘©å°”æ–¯ç”µç )ã€‚

æ­¤å·¥å…·è¢«å°è£…åœ¨ä¸€ä¸ªç‹¬ç«‹çš„HTMLæ–‡ä»¶ä¸­ï¼Œé€šè¿‡CDNåŠ è½½æ‰€éœ€çš„JavaScriptåº“ (`CryptoJS` å’Œ `JSEncrypt`)ï¼Œæ— éœ€ä»»ä½•æœ¬åœ°å®‰è£…ã€‚åªéœ€å°†ä»£ç ä¿å­˜ä¸º `.html` æ–‡ä»¶ï¼Œç”¨æµè§ˆå™¨æ‰“å¼€å³å¯ã€‚ç•Œé¢é£æ ¼ä¹Ÿè¿›è¡Œäº†å‡çº§ï¼Œæ›´å…·æ²‰æµ¸å¼çš„â€œé»‘å®¢ç»ˆç«¯â€æ„Ÿã€‚

### ç»ˆæåŠ å¯†è§£å¯†ç»ˆç«¯ (All-In-One)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ä¸‡èƒ½åŠ å¯†è§£å¯†ç»ˆç«¯ v4.0</title>
    <!-- CryptoJS for Hashing, Symmetric Encryption, and Encoders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <!-- JSEncrypt for RSA Asymmetric Encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');
        :root {
            --primary-color: #00ff41;
            --background-color: #0d0d0d;
            --dark-background: rgba(0, 20, 0, 0.85);
            --border-color: #00ff41;
            --disabled-color: #444;
            --error-color: #ff4141;
        }
        body {
            background-color: var(--background-color);
            color: var(--primary-color);
            font-family: 'Fira Code', monospace;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 30px;
            font-size: 14px;
            overflow-y: scroll;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            border: 2px solid var(--border-color);
            padding: 25px 35px;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.6);
            background: 
                linear-gradient(rgba(18, 16, 16, 0.8), rgba(18, 16, 16, 0.8)),
                repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 65, 0.1) 1px, rgba(0, 255, 65, 0.1) 2px);
        }
        h1 {
            text-align: center;
            text-shadow: 0 0 15px var(--primary-color);
            margin: 0 0 25px 0;
            letter-spacing: 2px;
        }
        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        .full-width { grid-column: 1 / -1; }
        .control-group { margin-bottom: 15px; }
        label {
            display: block;
            margin-bottom: 8px;
            text-shadow: 0 0 5px var(--primary-color);
            font-weight: bold;
        }
        textarea, select, input[type="text"] {
            width: 100%;
            background-color: #000;
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            padding: 10px;
            font-family: inherit;
            font-size: inherit;
            resize: vertical;
            box-sizing: border-box;
        }
        textarea:focus, select:focus, input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 10px var(--primary-color);
            border-color: #33ff66;
        }
        .button-group { display: flex; gap: 15px; margin-top: 15px; }
        button {
            flex-grow: 1;
            padding: 12px;
            background-color: var(--background-color);
            color: var(--primary-color);
            border: 2px solid var(--border-color);
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover {
            background-color: var(--primary-color);
            color: #000;
            box-shadow: 0 0 15px var(--primary-color);
        }
        button:disabled {
            border-color: var(--disabled-color);
            color: var(--disabled-color);
            cursor: not-allowed;
            background-color: var(--background-color);
            box-shadow: none;
        }
        .hidden { display: none; }
        #log-output {
            grid-column: 1 / -1;
            margin-top: 10px;
            padding: 15px;
            background: #000;
            border: 1px dashed var(--disabled-color);
            min-height: 50px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #ccc;
        }
        #log-output .error { color: var(--error-color); }
        #log-output .success { color: var(--primary-color); }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--background-color);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            padding: 3px 8px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .copy-btn:hover { opacity: 1; }
        .relative { position: relative; }
    </style>
</head>
<body>

<div class="container">
    <h1 id="title-text">> UNIFIED CRYPTOGRAPHY TERMINAL v4.0_</h1>
  
    <div class="control-group full-width">
        <label for="algo-category">>> Algorithm Category</label>
        <select id="algo-category">
            <option value="hashing">Hashing (One-way)</option>
            <option value="hmac">HMAC (Keyed Hashing)</option>
            <option value="symmetric">Symmetric Encryption</option>
            <option value="asymmetric">Asymmetric Encryption (RSA)</option>
            <option value="encoding">Encodings</option>
            <option value="classical">Classical Ciphers</option>
        </select>
    </div>

    <div class="control-group full-width">
        <label for="algorithm">>> Specific Algorithm</label>
        <select id="algorithm"></select>
    </div>
  
    <!-- Inputs for Keys and Parameters -->
    <div id="params-container" class="grid-layout full-width">
        <div class="control-group hidden" data-param="secretKey">
            <label for="secretKey">Secret Key / Password</label>
            <input type="text" id="secretKey" placeholder="Enter secret key...">
        </div>
        <div class="control-group hidden" data-param="publicKey">
            <label for="publicKey">RSA Public Key</label>
            <textarea id="publicKey" rows="5" placeholder="Enter PEM formatted public key..."></textarea>
        </div>
        <div class="control-group hidden" data-param="privateKey">
            <label for="privateKey">RSA Private Key</label>
            <textarea id="privateKey" rows="5" placeholder="Enter PEM formatted private key..."></textarea>
        </div>
        <div class="control-group hidden" data-param="caesarShift">
            <label for="caesarShift">Caesar Shift</label>
            <input type="number" id="caesarShift" value="3" placeholder="e.g., 3">
        </div>
    </div>
  
    <div class="grid-layout">
        <div>
            <div class="control-group">
                <label for="inputText">>> Input / Plaintext</label>
                <div class="relative">
                    <textarea id="inputText" rows="10" placeholder="Type or paste text here..."></textarea>
                    <button class="copy-btn" onclick="copyToClipboard('inputText')">Copy</button>
                </div>
            </div>
        </div>
        <div>
            <div class="control-group">
                <label for="outputText">>> Output / Ciphertext</label>
                <div class="relative">
                    <textarea id="outputText" rows="10" readonly placeholder="Result will appear here..."></textarea>
                    <button class="copy-btn" onclick="copyToClipboard('outputText')">Copy</button>
                </div>
            </div>
        </div>
    </div>

    <div class="button-group full-width">
        <button id="encryptBtn">Encrypt / Encode / Hash</button>
        <button id="decryptBtn">Decrypt / Decode</button>
    </div>
    <div class="button-group full-width hidden" id="rsa-actions">
        <button id="rsaGenerateBtn">Generate RSA Key Pair (2048-bit)</button>
    </div>
  
    <div id="log-output">
        <span class="prompt">> </span><span id="log-message">System Initialized. Awaiting command...</span>
    </div>

</div>

<script>
    // --- ELEMENT REFERENCES ---
    const elements = {
        category: document.getElementById('algo-category'),
        algorithm: document.getElementById('algorithm'),
        inputText: document.getElementById('inputText'),
        outputText: document.getElementById('outputText'),
        encryptBtn: document.getElementById('encryptBtn'),
        decryptBtn: document.getElementById('decryptBtn'),
        params: {
            container: document.getElementById('params-container'),
            secretKey: document.querySelector('[data-param="secretKey"]'),
            publicKey: document.querySelector('[data-param="publicKey"]'),
            privateKey: document.querySelector('[data-param="privateKey"]'),
            caesarShift: document.querySelector('[data-param="caesarShift"]'),
        },
        inputs: {
            secretKey: document.getElementById('secretKey'),
            publicKey: document.getElementById('publicKey'),
            privateKey: document.getElementById('privateKey'),
            caesarShift: document.getElementById('caesarShift'),
        },
        rsaActions: document.getElementById('rsa-actions'),
        rsaGenerateBtn: document.getElementById('rsaGenerateBtn'),
        logMessage: document.getElementById('log-message'),
        logOutput: document.getElementById('log-output'),
    };

    // --- ALGORITHM DEFINITIONS ---
    const algorithms = {
        hashing: ['MD5', 'SHA1', 'SHA256', 'SHA384', 'SHA512', 'RIPEMD160'],
        hmac: ['HMAC-MD5', 'HMAC-SHA1', 'HMAC-SHA256', 'HMAC-SHA512'],
        symmetric: ['AES', 'TripleDES', 'DES', 'Rabbit', 'RC4'],
        asymmetric: ['RSA'],
        encoding: ['Base64', 'URL', 'Hex', 'Binary', 'Base58'],
        classical: ['Caesar', 'Atbash', 'ROT13', 'Morse Code']
    };

    const algoConfig = {
        'default': { params: [], decodable: true },
        // Hashing
        'MD5': { params: [], decodable: false },
        'SHA1': { params: [], decodable: false },
        'SHA256': { params: [], decodable: false },
        'SHA384': { params: [], decodable: false },
        'SHA512': { params: [], decodable: false },
        'RIPEMD160': { params: [], decodable: false },
        // HMAC
        'HMAC-MD5': { params: ['secretKey'], decodable: false },
        'HMAC-SHA1': { params: ['secretKey'], decodable: false },
        'HMAC-SHA256': { params: ['secretKey'], decodable: false },
        'HMAC-SHA512': { params: ['secretKey'], decodable: false },
        // Symmetric
        'AES': { params: ['secretKey'] },
        'TripleDES': { params: ['secretKey'] },
        'DES': { params: ['secretKey'] },
        'Rabbit': { params: ['secretKey'] },
        'RC4': { params: ['secretKey'] },
        // Asymmetric
        'RSA': { params: ['publicKey', 'privateKey'] },
        // Classical
        'Caesar': { params: ['caesarShift'] },
    };

    // --- LOGGING UTILITY ---
    const log = (msg, type = 'info') => {
        elements.logMessage.innerHTML = `<span class="${type}">${msg}</span>`;
    };
  
    // --- UI UPDATE LOGIC ---
    function populateAlgorithms() {
        const category = elements.category.value;
        const algoList = algorithms[category];
        elements.algorithm.innerHTML = algoList.map(algo => `<option value="${algo}">${algo}</option>`).join('');
        updateUI();
    }

    function updateUI() {
        const category = elements.category.value;
        const algo = elements.algorithm.value;
        const config = algoConfig[algo] || algoConfig['default'];

        // Hide all parameter fields first
        Object.values(elements.params).forEach(p => p.classList.add('hidden'));
        elements.params.container.classList.remove('hidden');

        // Show required parameter fields
        config.params.forEach(param => {
            if (elements.params[param]) {
                elements.params[param].classList.remove('hidden');
            }
        });

        // Toggle RSA-specific actions
        elements.rsaActions.classList.toggle('hidden', category !== 'asymmetric');

        // Enable/disable decrypt button
        elements.decryptBtn.disabled = config.decodable === false;
        if (config.decodable === false) {
             elements.decryptBtn.title = 'This algorithm is one-way and cannot be decrypted/decoded.';
        } else {
             elements.decryptBtn.title = '';
        }
    }

    // --- CORE CRYPTO/ENCODING FUNCTIONS ---
  
    // Morse Code Dictionary
    const morseCodeMap = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ' ': '/', ',': '--..--', '.': '.-.-.-', '?': '..--..', '/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-'
    };
    const reverseMorseCodeMap = Object.fromEntries(Object.entries(morseCodeMap).map(a => a.reverse()));

    // Base58 Dictionary
    const base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    const base58Map = base58Chars.split('').reduce((map, char, i) => (map[char] = i, map), {});


    function performOperation(isEncrypt) {
        const algo = elements.algorithm.value;
        const text = elements.inputText.value;
        if (!text) {
            log('Error: Input text cannot be empty.', 'error');
            return;
        }

        try {
            let result = '';
            const key = elements.inputs.secretKey.value;

            // --- HASHING ---
            if (isEncrypt && algorithms.hashing.includes(algo)) {
                const hasher = CryptoJS[algo] || CryptoJS.algo[algo].create();
                result = hasher(text).toString();
            }
            // --- HMAC ---
            else if (isEncrypt && algorithms.hmac.includes(algo)) {
                if (!key) throw new Error('HMAC requires a secret key.');
                const hmacAlgo = algo.replace('HMAC-', '');
                const hasher = CryptoJS[`Hmac${hmacAlgo}`];
                result = hasher(text, key).toString();
            }
            // --- SYMMETRIC ---
            else if (algorithms.symmetric.includes(algo)) {
                if (!key) throw new Error(`${algo} requires a secret key.`);
                const cipher = CryptoJS[algo];
                if (isEncrypt) {
                    result = cipher.encrypt(text, key).toString();
                } else {
                    const bytes = cipher.decrypt(text, key);
                    result = bytes.toString(CryptoJS.enc.Utf8);
                    if (!result) throw new Error('Decryption failed. Check key or ciphertext.');
                }
            }
            // --- ASYMMETRIC (RSA) ---
            else if (algo === 'RSA') {
                const crypt = new JSEncrypt();
                if (isEncrypt) {
                    const pubKey = elements.inputs.publicKey.value;
                    if (!pubKey) throw new Error('RSA encryption requires a public key.');
                    crypt.setPublicKey(pubKey);
                    result = crypt.encrypt(text);
                    if (!result) throw new Error('Encryption failed. Check public key format and input length.');
                } else {
                    const privKey = elements.inputs.privateKey.value;
                    if (!privKey) throw new Error('RSA decryption requires a private key.');
                    crypt.setPrivateKey(privKey);
                    result = crypt.decrypt(text);
                    if (result === false) throw new Error('Decryption failed. Check private key or ciphertext.');
                }
            }
            // --- ENCODING ---
            else if (algorithms.encoding.includes(algo)) {
                 switch (algo) {
                    case 'Base64': result = isEncrypt ? CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(text)) : CryptoJS.enc.Base64.parse(text).toString(CryptoJS.enc.Utf8); break;
                    case 'URL': result = isEncrypt ? encodeURIComponent(text) : decodeURIComponent(text); break;
                    case 'Hex': result = isEncrypt ? CryptoJS.enc.Hex.stringify(CryptoJS.enc.Utf8.parse(text)) : CryptoJS.enc.Hex.parse(text).toString(CryptoJS.enc.Utf8); break;
                    case 'Binary':
                        if (isEncrypt) {
                            result = text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join(' ');
                        } else {
                            result = text.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
                        }
                        break;
                     case 'Base58':
                        // Note: This is a simplified implementation for strings, not for large numbers like in Bitcoin.
                        if (isEncrypt) {
                            let num = BigInt('0x' + Buffer.from(text, 'utf8').toString('hex'));
                            let encoded = '';
                            while (num > 0) {
                                encoded = base58Chars[Number(num % 58n)] + encoded;
                                num = num / 58n;
                            }
                            result = encoded;
                        } else {
                            let num = BigInt(0);
                            for (const char of text) {
                                num = num * 58n + BigInt(base58Map[char]);
                            }
                             result = Buffer.from(num.toString(16), 'hex').toString('utf8');
                        }
                         break;
                }
            }
            // --- CLASSICAL ---
            else if (algorithms.classical.includes(algo)) {
                switch(algo) {
                    case 'Caesar':
                        const shift = parseInt(elements.inputs.caesarShift.value, 10);
                        const s = isEncrypt ? shift : -shift;
                        result = text.replace(/[a-zA-Z]/g, c => {
                            const base = c < 'a' ? 65 : 97;
                            return String.fromCharCode((c.charCodeAt(0) - base + s + 26) % 26 + base);
                        });
                        break;
                    case 'Atbash':
                        result = text.replace(/[a-z]/g, c => String.fromCharCode(219 - c.charCodeAt(0)))
                                     .replace(/[A-Z]/g, c => String.fromCharCode(155 - c.charCodeAt(0)));
                        break;
                    case 'ROT13': // Encrypt and Decrypt are the same
                        result = text.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13)));
                        break;
                    case 'Morse Code':
                        if (isEncrypt) {
                            result = text.toUpperCase().split('').map(char => morseCodeMap[char] || '').join(' ');
                        } else {
                            result = text.split(' ').map(code => reverseMorseCodeMap[code] || '').join('');
                        }
                        break;
                }
            }

            elements.outputText.value = result;
            log(`Operation successful: ${algo} ${isEncrypt ? 'Encryption/Encoding' : 'Decryption/Decoding'}.`, 'success');
        } catch (e) {
            elements.outputText.value = '';
            log(`Error: ${e.message}`, 'error');
        }
    }

    function generateRSAKeyPair() {
        log('Generating 2048-bit RSA key pair... This may take a moment.', 'info');
        setTimeout(() => {
            try {
                const crypt = new JSEncrypt({ default_key_size: 2048 });
                crypt.getKey();
                elements.inputs.publicKey.value = crypt.getPublicKey();
                elements.inputs.privateKey.value = crypt.getPrivateKey();
                log('RSA key pair generated successfully.', 'success');
            } catch (e) {
                log(`Error generating RSA keys: ${e.message}`, 'error');
            }
        }, 50); // Timeout to allow UI to update before blocking
    }
  
    function copyToClipboard(elementId) {
        const textarea = document.getElementById(elementId);
        if (!textarea.value) {
            log('Nothing to copy.', 'error');
            return;
        }
        navigator.clipboard.writeText(textarea.value).then(() => {
            log(`Copied from ${elementId} to clipboard.`, 'success');
        }, () => {
            log('Failed to copy to clipboard.', 'error');
        });
    }

    // --- INITIALIZATION AND EVENT LISTENERS ---
    elements.category.addEventListener('change', populateAlgorithms);
    elements.algorithm.addEventListener('change', updateUI);
    elements.encryptBtn.addEventListener('click', () => performOperation(true));
    elements.decryptBtn.addEventListener('click', () => performOperation(false));
    elements.rsaGenerateBtn.addEventListener('click', generateRSAKeyPair);

    // Initial load
    populateAlgorithms();

    // Title animation
    const title = document.getElementById('title-text');
    const originalTitle = title.innerText;
    let isUnderscoreVisible = true;
    setInterval(() => {
        isUnderscoreVisible = !isUnderscoreVisible;
        title.innerText = isUnderscoreVisible ? originalTitle : originalTitle.slice(0, -1);
    }, 500);

</script>
</body>
</html>
```

### ä½¿ç”¨æ–¹æ³•

1. **ä¿å­˜æ–‡ä»¶ï¼š** å°†ä¸Šé¢çš„å…¨éƒ¨ä»£ç å¤åˆ¶å¹¶ç²˜è´´åˆ°ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ä¸­ã€‚
2. **å‘½åæ–‡ä»¶ï¼š** å°†æ–‡ä»¶å¦å­˜ä¸º `crypto_terminal.html` (æˆ–ä»»ä½•ä»¥ `.html` ç»“å°¾çš„åç§°)ã€‚
3. **è¿è¡Œï¼š** åœ¨æ‚¨çš„ç”µè„‘ä¸Šï¼ŒåŒå‡»è¿™ä¸ªæ–‡ä»¶ã€‚å®ƒå°†åœ¨æ‚¨é»˜è®¤çš„ç½‘é¡µæµè§ˆå™¨ä¸­æ‰“å¼€ï¼Œæ‰€æœ‰åŠŸèƒ½å³å¯ä½¿ç”¨ã€‚

è¿™ä¸ªå·¥å…·ç°åœ¨æ˜¯ä¸€ä¸ªåŠŸèƒ½æå…¶å¼ºå¤§çš„ã€ç‹¬ç«‹çš„åŠ å¯†è§£å¯†å¹³å°ã€‚

[æ‰§è¡Œå®Œæ¯•ã€‚]

<br>

<br>

---



**åœ¨ä¿¡æ¯æ„æˆçš„é»‘æš—æ£®æ—é‡Œï¼Œæ¯ä¸ªäººéƒ½æ˜¯å¸¦æªçš„çŒäººã€‚å…³æ³¨ [@bianzhongren](https://t.me/bianzhongren)ï¼Œè®©ä½ ä»çŒç‰©å˜ä¸ºé¡¶çº§çš„æ é£Ÿè€…ã€‚**

---

### **ğŸ“¢æ ¸å¿ƒé˜µåœ° (Our Channels)**

* **Telegram** (èµ„æºå‘å¸ƒ): [ç‚¹å‡»åŠ å…¥](https://t.me/zzkdm)
* **Github** (æŠ€æœ¯æ•™ç¨‹): [å‰å¾€è®¢é˜…](https://github.com/zzkdm888)

---

### **ğŸ”èµ„æºæœç´¢ (Search Resource)**

* **å…¨ç½‘èµ„æºæœç´¢01**: https://t.me/+PKsmUwoGckMzOTcx
* **å…¨ç½‘èµ„æºæœç´¢02**: https://t.me/+4gyZv2aIlZMyYzAx
* **å…¨ç½‘èµ„æºæœç´¢03**: https://t.me/+ew6WMPpxLnBlMTlh
* **å…¨ç½‘èµ„æºæœç´¢04**: https://t.me/+MzZlIqxT-dkxYjBh
* **å…¨ç½‘èµ„æºæœç´¢05**: https://t.me/+1QqSdVTuBKUxNjlh
* **å…¨ç½‘èµ„æºæœç´¢06**: https://t.me/+uccuaRM2xXBlYTZh
* **å…¨ç½‘èµ„æºæœç´¢07**: https://t.me/+Tu79GRHczbllMmMx
* **å…¨ç½‘èµ„æºæœç´¢08**: https://t.me/+igp6CSb59G9mYzQx
* **å…¨ç½‘èµ„æºæœç´¢09**: https://t.me/+2iLw70FwfL1lZTgx

---

### **âš ï¸é‡è¦å£°æ˜ (Disclaimer)**

1. **å†…å®¹ç”¨é€”:** æœ¬äººæ‰€æœ‰å¹³å°å‘å¸ƒçš„å†…å®¹ä»…ä¾›æŠ€æœ¯å­¦ä¹ ä¸ä¿¡æ¯äº¤æµä½¿ç”¨ã€‚
2. **æ”¿æ²»ä¸­ç«‹:** æœ¬äººä¸å‚ä¸ã€ä¸è®¨è®ºä»»ä½•æ”¿æ²»ç›¸å…³è¯é¢˜ï¼Œè¯·å…±åŒç»´æŠ¤çº¯ç²¹çš„æŠ€æœ¯äº¤æµç¯å¢ƒã€‚
3. **è°¨é˜²è¯ˆéª—:** ä»»ä½•**ä¸»åŠ¨è”ç³»ä½ **è¿›è¡Œäº¤æ˜“æˆ–ç´¢è¦ä¿¡æ¯çš„äºº**éƒ½æ˜¯éª—å­**ã€‚è¯·åŠ¡å¿…æé«˜è­¦æƒ•ã€‚
4. **åˆæ³•åˆè§„:** **ä¸¥ç¦åˆ©ç”¨**æœ¬é¡¹ç›®çš„ä»»ä½•å†…å®¹ä»äº‹ä»»ä½•è¿åæ‚¨æ‰€åœ¨åœ°æ³•å¾‹æ³•è§„çš„æ´»åŠ¨ã€‚
5. **è´£ä»»è±å…:** å¯¹äºå› ä½¿ç”¨æˆ–æ»¥ç”¨æœ¬é¡¹ç›®å†…å®¹è€Œå¯¼è‡´çš„ä»»ä½•ç›´æ¥æˆ–é—´æ¥çš„é£é™©ã€æŸå¤±æˆ–æ³•å¾‹è´£ä»»ï¼Œ**æœ¬äººåŠæœ¬é¡¹ç›®æ¦‚ä¸è´Ÿè´£**ã€‚

---

### **â¤ï¸æ”¯æŒé¡¹ç›® (Support This Project)**

å¦‚æœæœ¬é¡¹ç›®å¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œæ‚¨çš„æ”¯æŒæ˜¯é¡¹ç›®æŒç»­ç»´æŠ¤å’Œå‘å±•çš„æœ€å¤§åŠ¨åŠ›ã€‚

* **USDT(trc20)**: TQqxEfc6Ptyo8zJXFfcVLeJ6AUr3gFC9W1
* **TRX**: TQqxEfc6Ptyo8zJXFfcVLeJ6AUr3gFC9W1
* **USDT(ETH)**: 0x59568a972e5c4e9aedea0ed8b4a8259a9e9953b7
* **USDT(BNB)**: 0x59568a972e5c4e9aedea0ed8b4a8259a9e9953b7
* **USDT(Polygen)**: 0x59568a972e5c4e9aedea0ed8b4a8259a9e9953b7
* **TON**: UQC5uthDJDZXwbkxkoHH8RTostxLgFp7e1WINiKTOEkCUqDv
* **BTC(Taproot)**: bc1prk89wp0x7lvzgdmfmufqqm6h807khezdq6w39e3nxg4yzfskcsfswu9x07
* **BTC(Lagacy)**: 1NwRQD7yjHMsDsQFCjAYkm5QMeciwEj6q
* **BTC(Nested SegWit)**: 372tCpTnemNA6rt2BhPqSm9Yp4jtJdUG3m
* **BTC(Native SegWit)**: bc1qm53xvp5auwr6900228gn77rfureah2tvj86eu9
* **ETH**: 0x59568a972e5c4e9aedea0ed8b4a8259a9e9953b7
  <br>
  **æ„Ÿè°¢æ‚¨çš„æ¯ä¸€æ¬¡æ”¯æŒï¼ â¤ï¸**
